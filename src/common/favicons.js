
export const localhost =
	'data:image/svg+xml;base64,PD94bWwgdmVyc2lvbj0iMS4wIiBlbmNvZGluZz0iVVRGLTgiPz4KPHN2ZyB3aWR0aD0iMjYycHgiIGhlaWdodD0iMjYycHgiIHZpZXdCb3g9IjAgMCAyNjIgMjYyIiB2ZXJzaW9uPSIxLjEiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyIgeG1sbnM6eGxpbms9Imh0dHA6Ly93d3cudzMub3JnLzE5OTkveGxpbmsiPgogICAgPHRpdGxlPmxvY2FsaG9zdDwvdGl0bGU+CiAgICA8ZyBpZD0iUGFnZS0xIiBzdHJva2U9Im5vbmUiIHN0cm9rZS13aWR0aD0iMSIgZmlsbD0ibm9uZSIgZmlsbC1ydWxlPSJldmVub2RkIj4KICAgICAgICA8ZyBpZD0ibG9jYWxob3N0Ij4KICAgICAgICAgICAgPHJlY3QgaWQ9IlJlY3RhbmdsZSIgZmlsbD0iI0Q4RDhEOCIgeD0iMCIgeT0iMCIgd2lkdGg9IjI2MiIgaGVpZ2h0PSIyNjIiIHJ4PSI1MiI+PC9yZWN0PgogICAgICAgICAgICA8ZyBpZD0iaG9tZSIgdHJhbnNmb3JtPSJ0cmFuc2xhdGUoMzYuMDAwMDAwLCAzNi4wMDAwMDApIiBmaWxsPSIjMzMzMzMzIiBmaWxsLXJ1bGU9Im5vbnplcm8iPgogICAgICAgICAgICAgICAgPHBhdGggZD0iTTE4My40Njg3NSw4My4xMjUgTDE2Ni4yNSw2NS45MTgxMjUgTDE2Ni4yNSwyMy43NSBDMTY2LjI1LDE3LjIxODc1IDE2MC45MDYyNSwxMS44NzUgMTU0LjM3NSwxMS44NzUgTDE0Mi41LDExLjg3NSBDMTM1Ljk2ODc1LDExLjg3NSAxMzAuNjI1LDE3LjIxODc1IDEzMC42MjUsMjMuNzUgTDEzMC42MjUsMzAuMzE2ODc1IEwxMDYuODc1LDYuNTkwNjI1IEMxMDMuNjMzMTI1LDMuNTI2ODc1IDEwMC42NjQzNzUsMCA5NSwwIEM4OS4zMzU2MjUsMCA4Ni4zNjY4NzUsMy41MjY4NzUgODMuMTI1LDYuNTkwNjI1IEw2LjUzMTI1LDgzLjEyNSBDMi44MjYyNSw4Ni45ODQzNzUgMCw4OS43OTg3NSAwLDk1IEMwLDEwMS42ODU2MjUgNS4xMywxMDYuODc1IDExLjg3NSwxMDYuODc1IEwyMy43NSwxMDYuODc1IEwyMy43NSwxNzguMTI1IEMyMy43NSwxODQuNjU2MjUgMjkuMDkzNzUsMTkwIDM1LjYyNSwxOTAgTDcxLjI1LDE5MCBMNzEuMjUsMTMwLjYyNSBDNzEuMjUsMTI0LjA5Mzc1IDc2LjU5Mzc1LDExOC43NSA4My4xMjUsMTE4Ljc1IEwxMDYuODc1LDExOC43NSBDMTEzLjQwNjI1LDExOC43NSAxMTguNzUsMTI0LjA5Mzc1IDExOC43NSwxMzAuNjI1IEwxMTguNzUsMTkwIEwxNTQuMzc1LDE5MCBDMTYwLjkwNjI1LDE5MCAxNjYuMjUsMTg0LjY1NjI1IDE2Ni4yNSwxNzguMTI1IEwxNjYuMjUsMTA2Ljg3NSBMMTc4LjEyNSwxMDYuODc1IEMxODQuODcsMTA2Ljg3NSAxOTAsMTAxLjY4NTYyNSAxOTAsOTUgQzE5MCw4OS43OTg3NSAxODcuMTczNzUsODYuOTg0Mzc1IDE4My40Njg3NSw4My4xMjUgWiIgaWQ9IlBhdGgiPjwvcGF0aD4KICAgICAgICAgICAgPC9nPgogICAgICAgIDwvZz4KICAgIDwvZz4KPC9zdmc+'

export const notfound =
	'data:image/svg+xml;base64,PHN2ZyBoZWlnaHQ9IjI2MiIgdmlld0JveD0iMCAwIDI2MiAyNjIiIHdpZHRoPSIyNjIiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyI+PGcgZmlsbD0ibm9uZSIgZmlsbC1ydWxlPSJldmVub2RkIj48cmVjdCBmaWxsPSIjZDhkOGQ4IiBoZWlnaHQ9IjI2MiIgcng9IjUyIiB3aWR0aD0iMjYyIi8+PGcgdHJhbnNmb3JtPSJ0cmFuc2xhdGUoMzMuNzIyMzIxIDM2LjI0MDE4MSkiPjxwYXRoIGQ9Im0xMTguNjQ0NDExLjYyNTk3NDUyYzguMDU5NiAxLjg2MDcwNTM2IDE0LjI0MjM0MyA3LjU0NDcwMDIzIDE3LjA3NDc0NCAxNC42OTM5MTUyOCA3LjM3NjY5Mi0yLjE2OTcyMjcgMTUuNjYyNTctLjc5NzE1NjcgMjIuMDkxMDM0IDQuNDA4NTExMiA2LjEzOTU5OCA0Ljk3MTc0ODEgOS4yMTE0OTQgMTIuMzI3NjQyNiA4Ljk2MjQ2IDE5LjY1ODM2NzkgNy4xOTg1OCAxLjQwNTg3MzQgMTMuNjc0Njc2IDYuMDUzNjk4IDE3LjEzNzgwMiAxMy4xNTQxNTggMy42MjYwNCA3LjQzNDQ4NDkgMy4wOTk2NjEgMTUuODE2NDU2Ny0uNjczODYyIDIyLjUxNjgwMDkgNi4zMjg3NjYgNC4zNjc2OTA1IDEwLjQ3NjMxMSAxMS42NzA2MjU4IDEwLjQ3NjMxMSAxOS45NDIyNzIyIDAgOC4yNzE2NDYtNC4xNDc1NDUgMTUuNTc0NTgyLTEwLjQ3NjQzNCAxOS45NDI2MDMgMy43NzM2NDYgNi43MDAwMTMgNC4zMDAwMjUgMTUuMDgxOTg1LjY3Mzk4NSAyMi41MTY0Ny0zLjQ2MzEyNiA3LjEwMDQ2LTkuOTM5MjIyIDExLjc0ODI4NS0xNy4xMzc4NjMgMTMuMTU0ODE3LjI0OTA5NSA3LjMzMDA2Ni0yLjgyMjgwMSAxNC42ODU5NjEtOC45NjIzOTkgMTkuNjU3NzA5LTYuNDI4NDY0IDUuMjA1NjY4LTE0LjcxNDM0MiA2LjU3ODIzNC0yMi4wOTE5OTQgNC40MDgzNzgtMi44MzE0NDEgNy4xNDkzNDgtOS4wMTQxODQgMTIuODMzMzQzLTE3LjA3Mzc4NCAxNC42OTQwNDgtOC4wNTk1MjEgMS44NjA2ODctMTYuMTA4MTUzLS41Mzc2NTEtMjEuNzg3ODk3Ny01LjcyMTU3My01LjY3OTg3MTYgNS4xODM5MjItMTMuNzI4NTAzNyA3LjU4MjI2LTIxLjc4ODAyMzggNS43MjE1NzMtOC4wNTk2MDA0LTEuODYwNzA1LTE0LjI0MjM0MzUtNy41NDQ3LTE3LjA3NDc0NDItMTQuNjkzOTE1LTcuMzc2NjkxOCAyLjE2OTcyMy0xNS42NjI1Njk4Ljc5NzE1Ny0yMi4wOTEwMzQzLTQuNDA4NTExLTYuMTM5NTk3Ni00Ljk3MTc0OC05LjIxMTQ5NDItMTIuMzI3NjQzLTguOTYyNDYwNC0xOS42NTgzNjgtNy4xOTg1NzkyLTEuNDA1ODczLTEzLjY3NDY3NTUtNi4wNTM2OTgtMTcuMTM3ODAxMi0xMy4xNTQxNTgtMy42MjYwNDA1Ni03LjQzNDQ4NS0zLjA5OTY2MTE2LTE1LjgxNjQ1Ny42NzM4NjE0LTIyLjUxNjgwMS02LjMyODc2NTM0LTQuMzY3NjktMTAuNDc2MzEwOC0xMS42NzA2MjYtMTAuNDc2MzEwOC0xOS45NDIyNzIgMC04LjI3MTY0NjQgNC4xNDc1NDU0Ni0xNS41NzQ1ODE3IDEwLjQ3NjQzMzktMTkuOTQyNjAzNC0zLjc3MzY0NTY2LTYuNzAwMDEzLTQuMzAwMDI1MDYtMTUuMDgxOTg0OC0uNjczOTg0NS0yMi41MTY0Njk3IDMuNDYzMTI1Ny03LjEwMDQ2IDkuOTM5MjIyLTExLjc0ODI4NDYgMTcuMTM3ODYyNS0xMy4xNTQ4MTY3LS4yNDkwOTUxLTcuMzMwMDY2NiAyLjgyMjgwMTUtMTQuNjg1OTYxMSA4Ljk2MjM5OTEtMTkuNjU3NzA5MiA2LjQyODQ2NDUtNS4yMDU2Njc5IDE0LjcxNDM0MjUtNi41NzgyMzM5IDIyLjA5MTk5MzktNC40MDgzNzg0IDIuODMxNDQxMS03LjE0OTM0Nzg1IDkuMDE0MTg0Mi0xMi44MzMzNDI3MiAxNy4wNzM3ODQ2LTE0LjY5NDA0ODA4IDguMDU5NTIwMS0xLjg2MDY4Njg0IDE2LjEwODE1MjIuNTM3NjUxNDUgMjEuNzg3ODk3MyA1LjcyMTU3MzYxIDUuNjc5ODcxMi01LjE4MzkyMjE2IDEzLjcyODUwMzItNy41ODIyNjA0NSAyMS43ODgwMjQyLTUuNzIxNTczNjF6IiBmaWxsPSIjMzMzIi8+PHBhdGggZD0ibTcwLjE3NjE3ODYgNzMuMzM0OTAxNWgxMC43MjI4Njc3Yy43NjEzODctOS4wOTE2MzcyIDYuNjYyMTM2Ny0xNC42MjI5MTMgMTUuODYyMjMwMy0xNC42MjI5MTMgOC44ODI4NDk0IDAgMTQuOTczOTQ1NCA1LjQ2NzY5NzkgMTQuOTczOTQ1NCAxMy40Nzg1MTExIDAgNi42NzU2Nzc3LTIuNjY0ODU1IDEwLjY4MTA4NDMtOS45NjE0ODEgMTUuMjU4NjkxOS04LjU2NTYwNCA1LjI3Njk2NDItMTIuNDM1OTg4MiAxMC45MzUzOTU4LTEyLjMwOTA5MDMgMTkuMzkxMjU0NXY1Ljc4NTU4N2gxMS4wNDAxMTIzdi00LjEzMjU2MmMwLTYuNzM5MjU2IDIuMzQ3NjEtMTAuMjM2MDM5NSAxMC4wODgzNzktMTUuMDA0MzgwNyA4LjYyOTA1My01LjI3Njk2NDIgMTIuOTQzNTc5LTEyLjU4ODQyMDcgMTIuOTQzNTc5LTIxLjg3MDc5MTYgMC0xMy40Nzg1MTExLTEwLjk3NjY2My0yMy4wNzg3NzE0LTI2LjMzMTMwMTktMjMuMDc4NzcxNC0xNS44NjIyMzA0IDAtMjYuMjY3ODUzNSA5LjQ3MzEwNDUtMjcuMDI5MjQwNSAyNC43OTUzNzQyem0yNS4yNTI2NzA3IDY5LjA0NTU4MDVjNC44MjIxMTc3IDAgOC42OTI1MDI3LTQuMDA1NDA3IDguNjkyNTAyNy05LjAyODA1OSAwLTUuMDIyNjUzLTMuODcwMzg1LTkuMDI4MDYtOC42OTI1MDI3LTkuMDI4MDYtNC44MjIxMTggMC04LjY5MjUwMjIgNC4wMDU0MDctOC42OTI1MDIyIDkuMDI4MDYgMCA1LjAyMjY1MiAzLjg3MDM4NDIgOS4wMjgwNTkgOC42OTI1MDIyIDkuMDI4MDU5eiIgZmlsbD0iI2ZmZiIgZmlsbC1ydWxlPSJub256ZXJvIi8+PC9nPjwvZz48L3N2Zz4='


export default {
	url: handlerAsText,
	img: handlerAsBlob,
	uri: handlerAsIcon,
}

async function handlerAsIcon (url = ''){ 
	if(!url){
		return
	}
	const { protocol, hostname } = parseURL(url)
 
	// var domainRegex = /^(.*?:\/\/)?(?:www\.)?([^:\/\n]+)/;
	// var match = url.match(domainRegex);
	// var protocol = match && match[1]; 
	// var domain = match && match[2]; 
  
	return (await foundIconUrls(protocol+"://" +hostname , url))
}
 
const parseURL = (urlString) => {
    const url = {};
    const regex = /^(.*?):\/\/([^/]+)(\/[^?#]*)\??([^#]*)#?(.*)$/;
    const matches = urlString.match(regex);

    if (matches) {
      url.href = matches[0];
      url.protocol = matches[1];
      url.host = matches[2];
      url.pathname = matches[3];
      url.search = matches[4];
      url.hash = matches[5];
  
      // 解析主机名和端口
      const hostRegex = /^(.+):(\d+)$/;
      const hostMatches = url.host.match(hostRegex);
      if (hostMatches) {
        url.hostname = hostMatches[1];
        url.port = hostMatches[2];
      } else {
        url.hostname = url.host;
      }
    }
  
    return url;
};
 

async function handlerAsText(query) {
    const icons = await foundIconUrls(query) 
	for (const path of icons) { 
		if (path === 'localhost') {
			return localhost
		} 
		const result = await fetchIcon(path) 
		if (result) {
			return path
		}
	}

	return notfound
}

async function handlerAsBlob(query){
	for (const path of await foundIconUrls(query)) {
		//
		if (path === 'localhost') {
			return dataUriToBlob(localhost)
		}

		const blob = await fetchIcon(path)

		if (blob && blob.type.includes('image')) {
			return blob
		}
	}

	return dataUriToBlob(notfound)
}

async function foundIconUrls(query, domain) {
	if (query === '') {
		return []
	}

	//
	// Step 1: Is localhost

	if (['http://localhost', 'http://127.0.0.1'].some((path) => query.startsWith(path))) {
		return ['localhost']
	}

	//
	// Step 2: Is available from static list

	// const urlFromList = getURLFromWebsiteList(query, websites)

	// if (urlFromList) {
	// 	return [urlFromList]
	// }

	//
	// Step 3: Put and sort all potential icon paths in a list

	const icons = []
	const html = await fetchBody(query)

	if (html) {
		const head = parseHead(html)
  
		icons.push(...sortClosestToSize(head.icons, 144))


		if (head?.manifest) {
			const path = fullpath(head.manifest, query)
			const manifest = await fetchManifest(path)
 

			if (manifest) {
				const manifestIcons = parseManifest(manifest) 
				icons.unshift(...sortClosestToSize(manifestIcons, 144))
			}
		}
	} 

	if (icons.length === 0) {
		icons.push({
			href: `/favicon.ico`,
			size: -1024,
			touch: false,
		})
	}

	//
	// Step 4: Return list of href

	return icons.map((icon) => fullpath(icon.href, domain || query))
}

//
// Fetchers
//

// const headers = {
// 	'Cache-Control': 'max-age=0',
// 	'Accept-Language': 'en-US;q=0.9,en;q=0.7',
// 	'Sec-Ch-Ua': '"Not.A/Brand";v="8", "Chromium";v="114", "Google Chrome";v="114"',
// 	'Sec-Ch-Ua-Mobile': '?0',
// 	'Sec-Ch-Ua-Platform': '"macOS"',
// 	'Sec-Fetch-Dest': 'document',
// 	'Sec-Fetch-Site': 'none',
// 	'Sec-Fetch-User': '?1',
// 	'User-Agent':
// 		'Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15_7) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/114.0.0.0 Safari/537.36',
// }



async function fetchBody(url) {
	try {
        // .timeout(5000)
		const resp = await fetch(url)
		const text = await resp.text()
		return text
	} catch (_) {
		console.warn("Can't fetch HTML: " + url,  _)
	}
}

async function fetchManifest(url) {
	try { 
        // .timeout(2000)
		const resp = await fetch(url)
		const json = await resp.json()
		return json
	} catch (_) {
		console.warn("Can't fetch manifest: " + url)
	}
}

async function fetchIcon(url){
	try {
        // .timeout(2500)
		const resp = await fetch(url)

		if (resp.status === 200) {
			const blob = await resp.blob()
			return blob
		}
	} catch (_) {
		console.warn("Can't fetch icon: " + url)
	}
}
 
function parseManifest({ icons }) {
	if (icons) {
		return icons.map((icon) => ({
			href: icon.src,
			size: sizesToNumber(icon.sizes),
		}))
	}

	return []
}

function parseHead(html) {
	const result = { icons: [] }
	const endHeadTag = html.indexOf('</head>')

	if (endHeadTag > 0) {
		html = html.slice(0, endHeadTag)
	}

	if (html.indexOf('<script') > 0) {
		html = html
			.split('<script')
			.map((str) => str.slice(str.indexOf('</script>') + 9))
			.join()
	}

	const links = html.split('<link').map((str) => `<link ${str.slice(0, str.indexOf('>'))}>`)
	const metas = html.split('<meta').map((str) => `<meta ${str.slice(0, str.indexOf('>'))}>`)

	const sliceAttr = (str = '', from = '', to = '') => {
		const start = str.indexOf(from) + from.length
		const end = str.indexOf(to, start) + (to.length - 1)
		return str.substring(start, end)
	}

	for (const meta of metas) {
		const name = sliceAttr(meta, 'name="', '"').toLocaleLowerCase()
		const content = sliceAttr(meta, 'content="', '"')

		if (name.includes('apple-touch-icon')) {
			result.icons.push({ href: content, size: 100, touch: true })
		}
	}

	for (const link of links) {
		const rel = sliceAttr(link, 'rel="', '"').toLocaleLowerCase()
		const href = sliceAttr(link, 'href="', '"')
		const sizes = sliceAttr(link, 'sizes="', '"').toLocaleLowerCase()

		if (rel.includes('manifest')) {
			result.manifest = href
		}

		if (rel.includes('icon')) {
			result.icons.push({
				href,
				size: sizesToNumber(sizes),
				touch: rel.includes('apple-touch') || rel.includes('fluid') || rel.includes('mask'),
			})
		}
	}

	return result
}
  
function fullpath(url, query) {
	if (!url) return ''

	let queryURL 
	try {
		queryURL = parseURL(query)
	} catch (_) {
		return '' // ... error handling ?
	} 
 
	const { hostname, protocol, pathname } = queryURL
 
	if (url.startsWith('http')) {
		return url
	}

	// It means (https:)//
	if (url.startsWith('//')) {
		return `${protocol}:${url}`
	}

	// If icon from root, only add protocol & hostname
	// Absolute path, also gets pathname
	return `${protocol}://${hostname}${url.startsWith('/') ? '' : pathname}${url}`
}

function sortClosestToSize(icons , val){
	const sorted = icons.sort((a, b) => Math.abs(a.size - val) - Math.abs(b.size - val))
	return sorted
}

function sizesToNumber(str = '') {
	return parseInt(str?.split('x')[0]) || 48
}

// function getURLFromWebsiteList(query, websites){
// 	for (const { domain, url } of websites) {
// 		if (typeof domain === 'string') {
// 			if (query.includes(domain)) return url
// 		}

// 		if (typeof domain === 'object') {
// 			for (const item of domain) {
// 				if (query.includes(item)) return url
// 			}
// 		}
// 	}
// }

export function dataUriToBlob(uri) {
	const plain = atob(uri.replace('data:image/svg+xml;base64,', ''))
	const blob = new Blob([plain], { type: 'image/svg+xml' }) 
	return blob
}





